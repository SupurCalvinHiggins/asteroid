------------------------------------------------------------------
-- prologue.ast
--
-- the standard Asteroid prologue defining global functions.
--
-- (c) Lutz Hamel, University of Rhode Island
------------------------------------------------------------------

------------------------------------------------------------------
structure Error
------------------------------------------------------------------
-- use this structure to throw error exceptions
  with
  data err_val.
  end

------------------------------------------------------------------
function inherit
------------------------------------------------------------------
-- allow the user to construct an inheritance hierachy by directly
-- manipulating the structure types.
with (target,source) do escape
-- target inherits the whole structure of source
"
from asteroid_support import assert_match
from copy import deepcopy

target_val = state.symbol_table.lookup_sym('target')
source_val = state.symbol_table.lookup_sym('source')

# unpack target_val
(STRUCT,
    (MEMBER_NAMES, (LIST, t_member_names)),
    (STRUCT_MEMORY, (LIST, t_struct_memory)),
    (STRUCT_SCOPE, t_struct_scope)) = target_val

assert_match(STRUCT, 'struct')
target_len = len(t_member_names)

# unpack source_val
(STRUCT,
    (MEMBER_NAMES, (LIST, s_member_names)),
    (STRUCT_MEMORY, (LIST, s_struct_memory)),
    (STRUCT_SCOPE, s_struct_scope)) = source_val

assert_match(STRUCT, 'struct')

# construct the target structure
state.symbol_table.push_scope(t_struct_scope)
for ix in range(len(s_member_names)):
  if s_member_names[ix] in t_member_names:
    raise ValueError('inherit: clash in structure on {}'
                     .format(s_member_names[ix]))
  state.symbol_table.enter_sym(s_member_names[ix],
                               ('integer', ix+target_len))
  t_member_names.append(s_member_names[ix])
  t_struct_memory.append(deepcopy(s_struct_memory[ix]))
state.symbol_table.pop_scope()
"
orwith (target,source,slot:%string) do escape
-- target inherits slot from source
"
from asteroid_support import assert_match
from copy import deepcopy

target_val = state.symbol_table.lookup_sym('target')
source_val = state.symbol_table.lookup_sym('source')
slot_val = state.symbol_table.lookup_sym('slot')

# unpack target_val
(STRUCT,
    (MEMBER_NAMES, (LIST, t_member_names)),
    (STRUCT_MEMORY, (LIST, t_struct_memory)),
    (STRUCT_SCOPE, t_struct_scope)) = target_val

assert_match(STRUCT, 'struct')
target_len = len(t_member_names)

# unpack source_val
(STRUCT,
    (MEMBER_NAMES, (LIST, s_member_names)),
    (STRUCT_MEMORY, (LIST, s_struct_memory)),
    (STRUCT_SCOPE, s_struct_scope)) = source_val

assert_match(STRUCT, 'struct')

# make sure the slot name is actually there
if slot_val[1] in s_member_names:
  ix = s_member_names.index(slot_val[1])
else:
  raise ValueError('inherit: member {} not found in source structure'
                   .format(slot_val[1]))

if s_member_names[ix] in t_member_names:
  raise ValueError('inherit: clash in structure on {}'
                   .format(s_member_names[ix]))

# construct the target structure
state.symbol_table.push_scope(t_struct_scope)
state.symbol_table.enter_sym(slot_val[1], ('integer', ix+target_len))
state.symbol_table.pop_scope()
t_member_names.append(slot_val[1])
t_struct_memory.append(deepcopy(s_struct_memory[ix]))
"
end

------------------------------------------------------------------
function range
------------------------------------------------------------------
  with (start:%integer,stop:%integer) do
    return [start to stop-1].
  orwith (start:%integer,stop:%integer,inc:%integer) do
    return [start to stop-1 step inc].
  orwith stop:%integer do
    return [0 to stop-1].
  end

------------------------------------------------------------------
function isnone
------------------------------------------------------------------
-- Note: is this the more asteroidal approach:
--    return x is none.
with x do return escape
"
global __retval__

x_val = state.symbol_table.lookup_sym('x')

if x_val[0] == 'none':
  __retval__ = ('boolean', True)
else:
  __retval__ = ('boolean', False)
"
end

------------------------------------------------------------------
-- List member functions
------------------------------------------------------------------

-- NOTE: these functions must appear the
-- 'list_member_functions' dictionary

-- for implementation details see python lists in
-- https://docs.python.org/3/tutorial/datastructures.html

-- list member function association table
escape
"
global list_member_functions

list_member_functions.update({
    'length'    : '__list_length__',
    'append'    : '__list_append__',
    'extend'    : '__list_extend__',
    'insert'    : '__list_insert__',
    'remove'    : '__list_remove__',
    'pop'       : '__list_pop__',
    'clear'     : '__list_clear__',
    'index'     : '__list_index__',
    'count'     : '__list_count__',
    'sort'      : '__list_sort__',
    'reverse'   : '__list_reverse__',
    'copy'      : '__list_copy__',
    'shuffle'   : '__list_shuffle__',
    'map'       : '__list_map__',
    'reduce'    : '__list_reduce__',
    'filter'    : '__list_filter__',
    'member'    : '__list_member__',
    'join'      : '__list_join__',
    })
".
------------------------------------------------------------------
function __list_length__
------------------------------------------------------------------
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')

if self_val[0] != 'list':
   raise ValueError('__list_length__ expected a list got {}'
	     .format(self_val[0]))

__retval__ = ('integer', len(self_val[1]))
"
end

------------------------------------------------------------------
function __list_append__
------------------------------------------------------------------
-- Add an item to the end of the list.
with (self,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')

assert_match(self_val[0],'list')

self_val[1].append(item_val)
__retval__ = self_val
"
end

------------------------------------------------------------------
function __list_extend__
------------------------------------------------------------------
-- Extend the list by appending all the items
-- from the item where item is either a list,
-- a string or a tuple.
with (self,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')

assert_match(self_val[0],'list')
if item_val[0] not in ['list', 'string', 'tuple']:
    raise ValueError('__list_extend__ expected a list, string, or tuple, got {}''
                .format(item_val[0]))

__retval__ = ('list', self_val[1].extend(item_val[1]))
"
end

------------------------------------------------------------------
function __list_insert__
------------------------------------------------------------------
-- Insert an item at a given position. The first
-- argument is the index of the element before
-- which to insert, so a@insert(0, x) inserts at the
-- front of the list, and a@insert(a@length(), x) is
-- equivalent to a@append(x).
with (self,ix,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
ix_val = state.symbol_table.lookup_sym('ix')
item_val = state.symbol_table.lookup_sym('item')

assert_match(self_val[0],'list')
assert_match(ix_val[0],'integer')

__retval__ = ('list', self_val[1].insert(ix_val[1],item_val))
"
end

------------------------------------------------------------------
function __list_remove__
------------------------------------------------------------------
-- Remove the first element from the list whose
-- value is equal to item. It raises a ValueError
-- if there is no such item.
with (self,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')

assert_match(self_val[0],'list')
__retval__ = ('list', self_val[1].remove(ix_val[1],item_val))
"
end

------------------------------------------------------------------
function __list_pop__
------------------------------------------------------------------
-- Remove the item at the given position in
-- the list, and return it. If no index is specified,
-- a@pop() removes and returns the last item in the list.
with (self,ix) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
ix_val = state.symbol_table.lookup_sym('ix')

assert_match(self_val[0],'list')
assert_match(ix_val[0],'integer')

__retval__ = ('list', self_val[1].pop(ix_val[1]))
"
orwith self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'list')

__retval__ = ('list', self_val[1].pop())
"
end

------------------------------------------------------------------
function __list_clear__
------------------------------------------------------------------
-- Remove all items from the list.
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'list')
__retval__ = ('list, self_val[1].clear())
"
end

------------------------------------------------------------------
function __list_index__
------------------------------------------------------------------
-- Return zero-based index in the list of the first element whose value
-- is equal to item. Raises a ValueError if there is no such item.
-- The optional arguments startix and endix are interpreted as in the slice
-- notation and are used to limit the search to a particular subsequence of
-- the list. The returned index is computed relative to the beginning of the
-- full sequence rather than the startix argument.
with (self,item,startix,endix) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')
startix_val = state.symbol_table.lookup_sym('startix')
endix_val = state.symbol_table.lookup_sym('endix')

assert_match(self_val[0],'list')
assert_match(startix_val[0],'integer')
assert_match(endix_val[0],'integer')

__retval__ = ('integer', self_val[1].index(item_val,
                            startix_val[1],
                            endix_val[1]))
"
orwith (self,item,startix) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')
startix_val = state.symbol_table.lookup_sym('startix')

assert_match(self_val[0],'list')
assert_match(startix_val[0],'integer')

__retval__ = ('integer', self_val[1].index(item_val, startix_val[1]))
"
orwith (self,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')

assert_match(self_val[0],'list')

try:
  __retval__ = ('integer', self_val[1].index(item_val))
except ValueError:
  __retval__ = ('none', None)
"
end

------------------------------------------------------------------
function __list_count__
------------------------------------------------------------------
-- Return the number of times item appears in the list.
with (self,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')

assert_match(self_val[0],'list')

__retval__ = ('integer', self_val[1].count(item_val))
"
end

------------------------------------------------------------------
function __list_sort__
------------------------------------------------------------------
-- Sort the items of the list in place
with (self,reverse) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
reverse_val = state.symbol_table.lookup_sym('reverse')

assert_match(self_val[0],'list')
assert_match(reverse_val[0],'boolean')

self_val[1].sort(reverse=reverse_val[1])
__retval__ = self_val
"
orwith self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'list')
self_val[1].sort()
__retval__ = self_val
"
end

------------------------------------------------------------------
function __list_reverse__
------------------------------------------------------------------
-- Reverse the elements of the list in place.
with self do return escape
"
from asteroid_state import state
global __retval__

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'list')
self_val[1].reverse()
__retval__ = self_val
"
end

------------------------------------------------------------------
function __list_copy__
------------------------------------------------------------------
-- make a shallow copy of the list
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'list')
__retval__ = ('list', self_val[1].copy())
"
end

------------------------------------------------------------------
function __list_shuffle__
------------------------------------------------------------------
-- return a random permutation of a given list - in place!
with self do return escape
"
global __retval__
import random
import copy
from asteroid_support import assert_match

(LIST, self_val) = state.symbol_table.lookup_sym('self')
assert_match(LIST, 'list')
random.shuffle(self_val)
__retval__ = ('list', self_val)
"
end

------------------------------------------------------------------
function __list_map__
------------------------------------------------------------------
-- Apply f to each element of the list
with (self,f) do
    let r = [].
    for i in self do
        r @append(f i).
    end
    return r.
end

------------------------------------------------------------------
function __list_reduce__
------------------------------------------------------------------
-- Note: first arg to f is the accumulator
with (self,f) do
    let value = self@0.
    for i in 1 to self@length()-1 do
        let value = f(value,self@i).
    end
    return value.
orwith (self,f,init) do
    let value = init.
    for i in 0 to self@length()-1 do
        let value = f(value,self@i).
    end
    return value.
end

------------------------------------------------------------------
function __list_filter__
------------------------------------------------------------------
-- Construct an output list from those elements of the list for which
-- f returns true. If f is none, the identity function is assumed,
-- that is, all elements of input list that are false are removed.
with (self,f) do
    let out = [].
    for e in self do
        let out = out+([e] if f(e) else []).
    end
    return out.
end

------------------------------------------------------------------
function __list_member__
------------------------------------------------------------------
with (self,item) do
    if self @count(item) > 0 do
        return true.
    else do
        return false.
    end
end

------------------------------------------------------------------
function __list_join__
------------------------------------------------------------------
with (self,join) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
join_val = state.symbol_table.lookup_sym('join')

assert_match(self_val[0],'list')
assert_match(join_val[0],'string')

raw_list = []
for (t,v) in self_val[1]:
  if t != 'string':
    raise ValueError('__list_join__: string list only')
  raw_list.append(v)

__retval__ = ('string', join_val[1].join(raw_list))
"

end


------------------------------------------------------------------
-- String member functions
------------------------------------------------------------------

-- NOTE: these functions must appear the
-- 'string_member_functions' dictionary

-- for implementation details see python lists in
-- https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str
escape
"
global string_member_functions

string_member_functions.update({
    'length'    : '__string_length__',
    'explode'   : '__string_explode__',
    'trim'      : '__string_trim__',
    'replace'   : '__string_replace__',
    'split'     : '__string_split__',
    'toupper'   : '__string_toupper__',
    'tolower'   : '__string_tolower__',
    'index'     : '__string_index__',
    'flip'      : '__string_flip__',
    })
    "

------------------------------------------------------------------
function __string_length__
------------------------------------------------------------------
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'string')
__retval__ = ('integer', len(self_val[1]))
"
end

------------------------------------------------------------------
function __string_explode__
------------------------------------------------------------------
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'string')
__retval__ = ('list', [('string', char) for char in self_val[1]])
"
end

------------------------------------------------------------------
function __string_trim__
------------------------------------------------------------------
-- Return a copy of the string with the leading and trailing
-- characters removed. The what argument is a string specifying
-- the set of characters to be removed. If omitted or none, the what
-- argument defaults to removing whitespace. The what argument is
-- not a prefix or suffix; rather, all combinations of its values are stripped.
with (self,what) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
what_val = state.symbol_table.lookup_sym('what')

assert_match(self_val[0],'string')
assert_match(what_val[0],'string')

__retval__ = ('string', self_val[1].strip(what_val[1]))
"
orwith self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')

assert_match(self_val[0],'string')

__retval__ = ('string', self_val[1].strip())
"
end

------------------------------------------------------------------
function __string_replace__
------------------------------------------------------------------
-- Return a copy of the string with all occurrences of regular expression pattern
-- old replaced by the string new. If the optional argument count is given,
-- only the first count occurrences are replaced.
with (self:%string,old:%string,new:%string,count:%integer) do return escape
"
global __retval__
from re import sub
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
old_val = state.symbol_table.lookup_sym('old')
new_val = state.symbol_table.lookup_sym('new')
count_val = state.symbol_table.lookup_sym('count')

#assert_match(self_val[0],'string')
#assert_match(old_val[0],'string')
#assert_match(new_val[0],'string')
#assert_match(count_val[0],'integer')

__retval__ = ('string', sub(old_val[1], new_val[1], self_val[1], count_val[1]))
"
orwith (self:%string,old:%string,new:%string) do return escape
"
global __retval__
from re import sub
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
old_val = state.symbol_table.lookup_sym('old')
new_val = state.symbol_table.lookup_sym('new')

#assert_match(self_val[0],'string')
#assert_match(old_val[0],'string')
#assert_match(new_val[0],'string')

__retval__ = ('string', sub(old_val[1], new_val[1],self_val[1]))
"
end

------------------------------------------------------------------
function __string_split__
------------------------------------------------------------------
-- Return a list of the words in the string, using sep as the delimiter string.
-- If maxsplit is given, at most maxsplit splits are done (thus, the list will
-- have at most maxsplit+1 elements). If maxsplit is not specified or -1, then
-- there is no limit on the number of splits (all possible splits are made).
--
--  sep is given, consecutive delimiters are not grouped together and are
-- deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2']).
-- The sep argument may consist of multiple characters (for example,
-- '1<>2<>3'.split('<>') returns ['1', '2', '3']). Splitting an empty string with a
-- specified separator returns [''].
--
-- If sep is not specified or is None, a different splitting algorithm is applied: runs of
-- consecutive whitespace are regarded as a single separator, and the result will
-- contain no empty strings at the start or end if the string has leading or trailing
-- whitespace. Consequently, splitting an empty string or a string consisting of
-- just whitespace with a None separator returns [].
with (self,sep,count) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
sep_val = state.symbol_table.lookup_sym('sep')
count_val = state.symbol_table.lookup_sym('count')

assert_match(self_val[0],'string')
assert_match(sep_val[0],'string')
assert_match(count_val[0],'integer')

raw_list = self_val[1].split(sep_val[1], count_val[1])
ast_list = [('string',e) for e in raw_list]

__retval__ = ('list', ast_list)
"
orwith (self,sep) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
sep_val = state.symbol_table.lookup_sym('sep')

assert_match(self_val[0],'string')
assert_match(sep_val[0],'string')

raw_list = self_val[1].split(sep_val[1])
ast_list = [('string',e) for e in raw_list]

__retval__ = ('list', ast_list)
"
orwith self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')

assert_match(self_val[0],'string')

raw_list = self_val[1].split()
ast_list = [('string',e) for e in raw_list]

__retval__ = ('list', ast_list)
"
end

------------------------------------------------------------------
function __string_toupper__
------------------------------------------------------------------
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'string')

__retval__ = ('string', self_val[1].upper())
"
end

------------------------------------------------------------------
function __string_tolower__
------------------------------------------------------------------
with self do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
assert_match(self_val[0],'string')

__retval__ = ('string', self_val[1].lower())
"
end

------------------------------------------------------------------
function __string_index__
------------------------------------------------------------------
with (self,item,startix,endix) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')
startix_val = state.symbol_table.lookup_sym('startix')
endix_val = state.symbol_table.lookup_sym('endix')
assert_match(self_val[0],'string')
assert_match(item_val[0],'string')
assert_match(startix_val[0],'integer')
assert_match(endix_val[0],'integer')

val = self_val[1].find(item_val[1], startix_val[1], endix_val[1])
if val == -1:
    __retval__ = ('none', Non')
else:
    __retval__ = ('integer',val)
"
orwith (self,item,startix) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')
startix_val = state.symbol_table.lookup_sym('startix')
assert_match(self_val[0],'string')
assert_match(item_val[0],'string')
assert_match(startix_val[0],'integer')

val = self_val[1].find(item_val[1], startix_val[1])
if val == -1:
    __retval__ = ('none', None)
else:
    __retval__ = ('integer',val)
"
orwith (self,item) do return escape
"
global __retval__
from asteroid_state import state

self_val = state.symbol_table.lookup_sym('self')
item_val = state.symbol_table.lookup_sym('item')
assert_match(self_val[0],'string')
assert_match(item_val[0],'string')

val = self_val[1].find(item_val[1])
if val == -1:
    __retval__ = ('none', None)
else:
    __retval__ = ('integer',val)
"
end

------------------------------------------------------------------
function __string_flip__
------------------------------------------------------------------
with (self:%string) do
    return ((self @explode()) @reverse()) @join("").
end
